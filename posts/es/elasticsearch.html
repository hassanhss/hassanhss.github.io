<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Elasticsearch查询常见问题 | hassan</title>
    <meta name="description" content="查询常见问题">
    <link rel="stylesheet" href="/assets/style.dd5de40c.css">
    <link rel="modulepreload" href="/assets/app.4fa09c86.js">
    <link rel="modulepreload" href="/assets/posts_es_elasticsearch.md.f7704f13.lean.js">
    
    <meta name="twitter:title" content="Elasticsearch查询常见问题 | hassan">
  <meta property="og:title" content="Elasticsearch查询常见问题 | hassan">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><div class="theme"><header class="nav-bar" data-v-40587210><div class="sidebar-button" data-v-40587210><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="hassan, back to home" data-v-40587210 data-v-016a8bd8><!----> hassan</a><div class="flex-grow" data-v-40587210></div><div class="nav" data-v-40587210><nav class="nav-links" data-v-40587210 data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/" data-v-49fe041d>Home <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/pages/archives" data-v-49fe041d>Archives <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/pages/tags" data-v-49fe041d>Tags <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/pages/about" data-v-49fe041d>About <!----></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-17c48e2f><nav class="nav-links nav" data-v-17c48e2f data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/" data-v-49fe041d>Home <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/pages/archives" data-v-49fe041d>Archives <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/pages/tags" data-v-49fe041d>Tags <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/pages/about" data-v-49fe041d>About <!----></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-17c48e2f><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="#数据类型">数据类型</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#简单数据类型">简单数据类型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#复杂数据类型">复杂数据类型</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#创建索引">创建索引</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#setting设置">setting设置</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#mapping设置">mapping设置</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#dynamic-mapping自动创建mapping">Dynamic Mapping自动创建mapping</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#分词">分词</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#常用分词器">常用分词器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#ik-分词器">IK 分词器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#测试分词器">测试分词器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#创建索引执行分词器">创建索引执行分词器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#分词工作流程">分词工作流程</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#什么是倒排索引">什么是倒排索引</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#倒排索引数据结构">倒排索引数据结构</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#倒排索引的生成">倒排索引的生成</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#查询">查询</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tf、idf">TF、IDF</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#搜索语法">搜索语法</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#match-all-查询所有文档">match_all 查询所有文档</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#match-单个字段匹配">match 单个字段匹配</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#multi-match-多字段匹配">multi_match 多字段匹配</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#match-phrase-短语匹配">match_phrase 短语匹配</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#term-单值精确查询">term 单值精确查询</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#terms-多值精确匹配">terms 多值精确匹配</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#prefix-前缀匹配">prefix 前缀匹配</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#wildcard-通配符匹配">wildcard 通配符匹配</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#regexp-正则匹配">regexp 正则匹配</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#fuzzy-近似匹配">fuzzy 近似匹配</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#range-区间匹配">range 区间匹配</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#exists-匹配指定字段非空的文档">exists 匹配指定字段非空的文档</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#ids-id数值匹配">ids id数值匹配</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#term、match-区别">term、match 区别</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#bool-布尔查询">bool 布尔查询</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#query-string-字符串匹配">query_string 字符串匹配</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#分页">分页</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#from-size-分页操作与深分页问题">from + size 分页操作与深分页问题</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#search-after">search after</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#scroll-api">scroll API</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#pit">PIT</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#精确匹配">精确匹配</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#忽略大小写">忽略大小写</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#分词技巧">分词技巧</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#返回数据具体总条数">返回数据具体总条数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#返回指定字段">返回指定字段</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#copy-to">copy_to</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#执行性能">执行性能</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#term-suggester">Term Suggester</a><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-8fcebc32><div class="container" data-v-8fcebc32><!--[--><!--]--><div style="position:relative;" class="content" data-v-8fcebc32><div><h1 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-hidden="true">#</a></h1><ul><li><p>Cluster 集群：由多个协同工作的 ES 实例组合成的集合，一个集群由一个唯一的名字标识</p></li><li><p>Node 节点：单个 ES 的服务实例叫做节点，本质上就是一个 Java 进程，存储集群的数据，参与集群的索引和搜索功能</p><ul><li>主节点（Master）。主节点在整个集群是唯一的，Master 从有资格进行选举的节点（Master Eligible）中选举出来。主节点主要负责管理集群变更、元数据的更改</li><li>数据节点（Data Node）。其负责保存数据，要扩充存储时候需要扩展这类节点。数据节点还负责执行数据相关的操作，如：搜索、聚合、CURD 等。所以对节点机器的 CPU、内存、I/O 要求都比较高</li><li>协调节点（Coordinating Node）。负责接受客户端的请求，将请求路由到对应的节点进行处理，并且把最终结果汇总到一起返回给客户端。因为需要处理结果集和对其进行排序，需要较高的 CPU 和内存资源</li></ul></li><li><p>Index 索引: 一个索引是一个文档的集合。每个索引有唯一的名字，通过这个名字来操作它。一个集群中可以有任意多个索引</p></li><li><p>Type 类型：指在一个索引中，可以索引不同类型的文档，如用户数据、商品数据。从6.0.0 版本起已废弃，一个索引中只存放一类数据</p></li><li><p>Document 文档：被索引的一条数据，索引的基本信息单元，以JSON格式来表示</p></li><li><p>Shard 分片：在创建一个索引时可以指定分成多少个分片来存储。每个分片本身也是一个功能完善且独立的“索引”，可以被放置在集群的任意节点上。分片的好处是允许我们水平切分/扩展容量可在多个分片上进行分布式的、并行的操作，提高系统的性能和吞吐量</p></li><li><p>Replication 备份: 一个分片可以有多个备份（副本）</p></li></ul><p>关系数据库和elasticsearch对比如下</p><p><img src="/assets/dbvses.38f397da.png" alt=""></p><h1 id="索引操作" tabindex="-1">索引操作 <a class="header-anchor" href="#索引操作" aria-hidden="true">#</a></h1><h2 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-hidden="true">#</a></h2><h3 id="简单数据类型" tabindex="-1">简单数据类型 <a class="header-anchor" href="#简单数据类型" aria-hidden="true">#</a></h3><p><img src="/assets/datatype.c603a512.png" alt=""></p><h3 id="复杂数据类型" tabindex="-1">复杂数据类型 <a class="header-anchor" href="#复杂数据类型" aria-hidden="true">#</a></h3><h4 id="数据类型-1" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型-1" aria-hidden="true">#</a></h4><ul><li>字符串数组：[&quot;tom&quot;,&quot;jerry&quot;]</li><li>整数数组：[1,2,3]</li><li>由数组组成的数组：[1,[2,3]],等价于[1,2,3]</li><li>对象数组：[{&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20}, {&quot;name&quot;: &quot;Jerry&quot;, &quot;age&quot;: 18}]</li></ul><p>注意：</p><ul><li>动态添加数据时, 数组中第一个值的类型决定整个数组的类型</li><li>不支持混合数组类型, 比如[1, “abc”]</li><li>数组可以包含null值, 空数组[]会被当做missing field —— 没有值的字段</li></ul><h4 id="对象类型" tabindex="-1">对象类型 <a class="header-anchor" href="#对象类型" aria-hidden="true">#</a></h4><div class="language-"><pre><code>{
    &quot;name&quot;: &quot;tom&quot;,
    &quot;address&quot;: {
        &quot;region&quot;: &quot;China&quot;,
        &quot;location&quot;: {&quot;province&quot;: &quot;ZheJiang&quot;, &quot;city&quot;: &quot;HangZhou&quot;}
    }
}
</code></pre></div><h4 id="嵌套类型" tabindex="-1">嵌套类型 <a class="header-anchor" href="#嵌套类型" aria-hidden="true">#</a></h4><p>嵌套类型是对象类型的特例，可以让array类型的对象被独立索引和搜索</p><p>如果需要对以对象进行索引, 且保留数组中每个对象的独立性, 就应该使用嵌套数据类型</p><div class="language-"><pre><code># 创建文档
{
  &quot;group&quot;: &quot;stark&quot;,
	&quot;performer&quot;: [
        {&quot;first&quot;: &quot;John&quot;, &quot;last&quot;: &quot;Snow&quot;},
        {&quot;first&quot;: &quot;Sansa&quot;, &quot;last&quot;: &quot;Stark&quot;}
    ]
}
</code></pre></div><p>搜索</p><div class="language-"><pre><code>{
    &quot;query&quot;: {
        &quot;nested&quot;: {
            &quot;path&quot;: &quot;performer&quot;,
            &quot;query&quot;: {
                &quot;bool&quot;: {
                    &quot;must&quot;: [
                        { &quot;match&quot;: { &quot;performer.first&quot;: &quot;John&quot; }},
                        { &quot;match&quot;: { &quot;performer.last&quot;:  &quot;Snow&quot; }} 
                    ]
                }
            }
        }
    }
}
</code></pre></div><h4 id="特殊类型" tabindex="-1">特殊类型 <a class="header-anchor" href="#特殊类型" aria-hidden="true">#</a></h4><p>地理形状类型 、IP类型等等</p><h2 id="创建索引" tabindex="-1">创建索引 <a class="header-anchor" href="#创建索引" aria-hidden="true">#</a></h2><p>创建索引</p><div class="language-"><pre><code>PUT /my_index
{
  # settings
  # mappings
}
</code></pre></div><h2 id="setting设置" tabindex="-1">setting设置 <a class="header-anchor" href="#setting设置" aria-hidden="true">#</a></h2><div class="language-"><pre><code>{
  &quot;settings&quot;: {
    # 主分片数
    &quot;number_of_shards&quot;: 5,
    # 副本分片数
    &quot;number_of_replicas&quot;: 1,
    # 设置一些过滤器
    &quot;analysis&quot;: {
      # keyword类型搜索忽略大小写
      &quot;normalizer&quot;: {
        &quot;lowercase_normalizer&quot;: {
          &quot;type&quot;: &quot;custom&quot;,
          &quot;char_filter&quot;: [],
          &quot;filter&quot;: [
            &quot;lowercase&quot;
          ]
        }
      }
    }
  },
  &quot;mappings&quot;: {}
}
</code></pre></div><h2 id="mapping设置" tabindex="-1">mapping设置 <a class="header-anchor" href="#mapping设置" aria-hidden="true">#</a></h2><h3 id="dynamic-mapping自动创建mapping" tabindex="-1">Dynamic Mapping自动创建mapping <a class="header-anchor" href="#dynamic-mapping自动创建mapping" aria-hidden="true">#</a></h3><p><img src="/assets/dynamicmapping.8c60da44.png" alt=""></p><h2 id="分词" tabindex="-1">分词 <a class="header-anchor" href="#分词" aria-hidden="true">#</a></h2><h3 id="常用分词器" tabindex="-1">常用分词器 <a class="header-anchor" href="#常用分词器" aria-hidden="true">#</a></h3><ul><li>Standard Analyzer ： 这个是默认的分词器，使用 Unicode 文本分割算法，将文本按单词切分并且转为小写</li><li>Simple Analyzer ： 按照非字母切分并且进行小写处理</li><li>Stop Analyzer ： 与 Simple Analyzer 类似，但增加了停用词过滤（如 a、an、and、are、as、at、be、but 等）</li><li>Whitespace Analyzer ： 使用空格对文本进行切分，并不进行小写转换</li><li>Patter n Analyzer ： 使用正则表达式切分，默认使用 \W+ (非字符分隔)。支持小写转换和停用词删除</li><li>keyword Analyzer ： 不进行分词</li><li>Language Analyzer ： 提供了多种常见语言的分词器。如 Irish、Italian、Latvian 等</li><li>Customer Analyzer：自定义分词器</li></ul><h3 id="ik-分词器" tabindex="-1">IK 分词器 <a class="header-anchor" href="#ik-分词器" aria-hidden="true">#</a></h3><p>IK 的算法是基于词典的，其支持自定义词典和词典热更新。IK 分词器插件一定要和es的版本相对应，具体安装参考 <a href="https://github.com/infinilabs/analysis-ik" target="_blank" rel="noopener noreferrer">https://github.com/infinilabs/analysis-ik</a></p><p>IK 有两种模式：ik_max_word 和 ik_smart</p><ul><li>ik_max_word： 会将文本做最细粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国、中华人民、中华、华人、人民共和国、人民、人、民、共和国、共和、和、国国、国歌”，会穷尽各种可能的组合</li><li>ik_smart： 会做最粗粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国、国歌”，适合 Phrase 查询</li></ul><h3 id="测试分词器" tabindex="-1">测试分词器 <a class="header-anchor" href="#测试分词器" aria-hidden="true">#</a></h3><div class="language-"><pre><code>POST _analyze
{  
    &quot;analyzer&quot;: &quot;ik_max_word&quot;,
    &quot;text&quot;: &quot;Linus 在90年代开发出了linux操作系统&quot;  
}

POST _analyze
{  
    &quot;analyzer&quot;: &quot;ik_smart&quot;,
    &quot;text&quot;: &quot;Linus 在90年代开发出了linux操作系统&quot;  
}
</code></pre></div><h3 id="创建索引执行分词器" tabindex="-1">创建索引执行分词器 <a class="header-anchor" href="#创建索引执行分词器" aria-hidden="true">#</a></h3><div class="language-"><pre><code>{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;title&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      }
    }
  }
}
</code></pre></div><h3 id="分词工作流程" tabindex="-1">分词工作流程 <a class="header-anchor" href="#分词工作流程" aria-hidden="true">#</a></h3><p><img src="/assets/ik.c1d4b3a7.png" alt=""></p><ul><li>character filters: 对输入进行预处理，比如删除 html 元素、将表情符号映射为文本</li><li>tokenizer: 按照指定的规则对文本进行切分，比如按空格来切分单词，同时也负责标记出每个单词的顺序、位置以及单词在原文本中开始和结束的偏移量</li><li>token filters: 对切分后的单词进行处理，如转换为小写、删除停用词、增加同义词、词干化等。例如输入 Is this déja vu, 如果按照空格分词的话，会被分为 Is, this, déja, vu。我们可以设置 asciifolding token filters, 将 déja, 转换为 deja，lowercase将大写转换为小写</li></ul><div class="language-"><pre><code>{
  &quot;char_filter&quot;: [&quot;html_strip&quot;,
    {
      &quot;type&quot;: &quot;mapping&quot;,
      &quot;mappings&quot;: [
        &quot;😊 =&gt; happy&quot;
      ]
    }
  ],
  &quot;tokenizer&quot;: {
    &quot;type&quot;: &quot;standard&quot;
  },
  &quot;filter&quot;: [],
  &quot;text&quot;: [
    &quot;Tom &amp;amp; Jerrey &amp;lt; &lt;b&gt;world&lt;/b&gt; 😊&quot;
  ]
}

{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;my_text&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;my_analyzer&quot;
      }
    }
  },
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;analyzer&quot;: {
        &quot;my_analyzer&quot;: {
          &quot;type&quot;: &quot;custom&quot;,
          &quot;char_filter&quot;: [
            &quot;html_strip&quot;,
            &quot;emo_to_word&quot;
          ],
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;lowercase&quot;
          ]
        }
      },
      &quot;char_filter&quot;: {
        &quot;emo_to_word&quot;: {
          &quot;type&quot;: &quot;mapping&quot;,
          &quot;mappings&quot;: [
            &quot;😊 =&gt; happy&quot;
          ]
        }
      }
    }
  }
}
</code></pre></div><h2 id="什么是倒排索引" tabindex="-1">什么是倒排索引 <a class="header-anchor" href="#什么是倒排索引" aria-hidden="true">#</a></h2><p>倒排索引指的是将每一个关键字映射到它出现的文档中。如下图所示</p><p><img src="/assets/inverted_one.02dc9681.png" alt=""></p><h3 id="倒排索引数据结构" tabindex="-1">倒排索引数据结构 <a class="header-anchor" href="#倒排索引数据结构" aria-hidden="true">#</a></h3><p>倒排索引分为 2 部分：一部分叫 term directory(term 词典)，一部分叫 posting list(倒排列表)。如下图所示</p><p><img src="/assets/inverted_two.4a34d6a3.png" alt=""></p><ul><li>term directory，term 字典，存放着每个单词到对应倒排列表的映射关系</li><li>posting list，Docs 是一个数组。其中 1:2:[2,6] 意思如下 <ul><li>1：文档ID</li><li>2：词频(term frequency)</li><li>[2,6]：出现在文档中的第 2，6 个 term</li></ul></li></ul><h3 id="倒排索引的生成" tabindex="-1">倒排索引的生成 <a class="header-anchor" href="#倒排索引的生成" aria-hidden="true">#</a></h3><p>这里涉及到我们之前讲过的分词器。工作流程如下图所示</p><p><img src="/assets/inverted_three.f7daafa9.png" alt=""></p><p>大体就包含2部分，根据分词器将文本分词，然后根据分词生成倒排索引。</p><h3 id="查询" tabindex="-1">查询 <a class="header-anchor" href="#查询" aria-hidden="true">#</a></h3><p>例如我们查询：To do right 则该文本会先被分词为：to, do, right 对应的结果如下图所示：</p><p><img src="/assets/inverted_four.09722811.png" alt=""></p><h3 id="tf、idf" tabindex="-1">TF、IDF <a class="header-anchor" href="#tf、idf" aria-hidden="true">#</a></h3><p>默认情况下，ES 会根据文档与搜索词的相关性得分对结果降序返回。相关性得分与以下 2 个概念有关</p><ul><li>Term Frequency(TF)：term 在文档中出现的频率，得分正相关。出现频率越高，得分越高</li><li>Inverted Document Frequency(IDF)：term 在 所有文档 中出现的频率，得分负相关。出现频率越高，得分越低</li></ul><p>ES5之前默认的算分采用TF-IDF，ES5之后采用BM25</p><p>BM25是在TF-DF基础上做了一个收敛，避免了TF无限增长时得分无限增长的问题</p><h2 id="搜索语法" tabindex="-1">搜索语法 <a class="header-anchor" href="#搜索语法" aria-hidden="true">#</a></h2><h3 id="match-all-查询所有文档" tabindex="-1">match_all 查询所有文档 <a class="header-anchor" href="#match-all-查询所有文档" aria-hidden="true">#</a></h3><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  }
}
</code></pre></div><h3 id="match-单个字段匹配" tabindex="-1">match 单个字段匹配 <a class="header-anchor" href="#match-单个字段匹配" aria-hidden="true">#</a></h3><p>单个字段的查询，先对搜索词进行分词，然后再搜索。</p><p>keyword：不分词精确匹配</p><p>text：分词后匹配</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;title&quot;: &quot;数据库&quot;, # text的会匹配&quot;数据库&quot;、&quot;数据&quot;...
    }
  }
}
</code></pre></div><h3 id="multi-match-多字段匹配" tabindex="-1">multi_match 多字段匹配 <a class="header-anchor" href="#multi-match-多字段匹配" aria-hidden="true">#</a></h3><p>为能在多个字段上反复执行相同查询提供了一种便捷方式</p><p>keyword：不分词精确匹配</p><p>text：分词匹配</p><p>Type:</p><ul><li>最佳字段（best_fields）：取fields中分数最高的，侧重于字段维度，单个字段的得分权重大，对于同一个query，单个field匹配更多的term，则优先排序。</li><li>混合字段（cross_fields）：类似于copy_to，就是类似于把所有字段文字都拼接起来，然后算评分</li></ul><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;multi_match&quot;: {
      &quot;type&quot;: &quot;best_fields&quot;, # 取fields中最高的评分
      &quot;query&quot;: &quot;数据库&quot;,
      &quot;fields&quot;: [&quot;title&quot;,&quot;content&quot;]
    }
  }
}


{
  &quot;query&quot;: {
    &quot;multi_match&quot;: {
      &quot;type&quot;: &quot;cross_fields&quot;, # fields中字段全部拼接到一起算分
      &quot;operator&quot;: &quot;and&quot;
      &quot;query&quot;: &quot;数据库&quot;,
      &quot;fields&quot;: [&quot;title^5&quot;,&quot;content&quot;], # 与copy_to相比，其优势是可以在搜索时为单个字段提升权重
    }
  }
}
</code></pre></div><h3 id="match-phrase-短语匹配" tabindex="-1">match_phrase 短语匹配 <a class="header-anchor" href="#match-phrase-短语匹配" aria-hidden="true">#</a></h3><p>短语匹配查询，slop表示分词的跨度，指分词和分词之间可以相隔多少个词，缺失了这些词仍然可以查到结果</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;title&quot;: {
        &quot;query&quot;: &quot;数据库&quot;,
        &quot;slop&quot;: 4
      }
    }
  }
}
</code></pre></div><h3 id="term-单值精确查询" tabindex="-1">term 单值精确查询 <a class="header-anchor" href="#term-单值精确查询" aria-hidden="true">#</a></h3><p>单个字段的精确查询</p><p>keyword：不分词精确匹配</p><p>text：不分词匹配</p><p>如果是keyword类型查询的时候，不需要指定keyword关键字。如果是text类型的在全匹配的时候需要指定keyword关键字</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;title&quot;: &quot;红楼梦&quot;
    }
  }
}

{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;content.keyword&quot;: &quot;当时社会的阶级关系和权力结构&quot;
    }
  }
}

# 大小写不敏感查询
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;title&quot;: {
        &quot;value&quot;: &quot;Romeo&quot;,
        &quot;case_insensitive&quot;: true
      }
    }
  }
}
</code></pre></div><h3 id="terms-多值精确匹配" tabindex="-1">terms 多值精确匹配 <a class="header-anchor" href="#terms-多值精确匹配" aria-hidden="true">#</a></h3><p>精确匹配多个值，只要被查字段包含指定数组中任何一个值就算符合条件，不能设置大小写敏感， 如果需要大小写不敏感需要在创建索引时指定</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;terms&quot;: {
      &quot;title&quot;: [&quot;红楼梦&quot;,&quot;西游记&quot;]
    }
  }
}
</code></pre></div><h3 id="prefix-前缀匹配" tabindex="-1">prefix 前缀匹配 <a class="header-anchor" href="#prefix-前缀匹配" aria-hidden="true">#</a></h3><p>匹配符合前缀要求的倒排索引数据。</p><p>注意：需要区分大小写，搜索词要是小写（或者定义mapping和settings的时候给这个字段设置忽略大小写），因为文档的词都是小写的</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;prefix&quot;:{
      &quot;title&quot;:&quot;rom&quot;
    }
  }
}
</code></pre></div><h3 id="wildcard-通配符匹配" tabindex="-1">wildcard 通配符匹配 <a class="header-anchor" href="#wildcard-通配符匹配" aria-hidden="true">#</a></h3><p>通配符（*表示任何字符串，?表示任何单个字符）匹配倒排索引</p><p>注意：需要区分大小写，搜索词要是小写（或者定义mapping和settings的时候给这个字段设置忽略大小写），因为文档的词都是小写的</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;wildcard&quot;: {
      &quot;title&quot;: &quot;ro*&quot;
    }
  }
}
</code></pre></div><h3 id="regexp-正则匹配" tabindex="-1">regexp 正则匹配 <a class="header-anchor" href="#regexp-正则匹配" aria-hidden="true">#</a></h3><p>正则表达式匹配倒排索引</p><p>注意：需要区分大小写，搜索词要是小写（或者定义mapping和settings的时候给这个字段设置忽略大小写），因为文档的词都是小写的</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;regexp&quot;: {
      &quot;title&quot;: &quot;.*iet&quot;
    }
  }
}
</code></pre></div><h3 id="fuzzy-近似匹配" tabindex="-1">fuzzy 近似匹配 <a class="header-anchor" href="#fuzzy-近似匹配" aria-hidden="true">#</a></h3><p>fuzziness用于控制levenshtein距离，区分大小写</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;fuzzy&quot;: {
      &quot;author&quot;: {
        &quot;value&quot;: &quot;Shakespea&quot;,
        &quot;fuzziness&quot;: 2
      }
    }
  }
}
</code></pre></div><h3 id="range-区间匹配" tabindex="-1">range 区间匹配 <a class="header-anchor" href="#range-区间匹配" aria-hidden="true">#</a></h3><p>区间匹配，</p><p>可以使用：gt（大于）、gte（大于等于）、lt（小于）、lte（小于等于）</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;range&quot;: {
      &quot;count&quot;: {
        &quot;gte&quot;: 30,
        &quot;lte&quot;: 70
      }
    }
  }
}
</code></pre></div><h3 id="exists-匹配指定字段非空的文档" tabindex="-1">exists 匹配指定字段非空的文档 <a class="header-anchor" href="#exists-匹配指定字段非空的文档" aria-hidden="true">#</a></h3><p>查询指定字段值不为null的数据，用于把某个字段不为null的文档往前排</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;exists&quot;: {
      &quot;field&quot;: &quot;title&quot;
    }
  }
}
</code></pre></div><h3 id="ids-id数值匹配" tabindex="-1">ids id数值匹配 <a class="header-anchor" href="#ids-id数值匹配" aria-hidden="true">#</a></h3><p>用于通过文档id数组匹配文档</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;ids&quot;: {
      &quot;values&quot;: [1,3]
    }
  }
}
</code></pre></div><h3 id="term、match-区别" tabindex="-1">term、match 区别 <a class="header-anchor" href="#term、match-区别" aria-hidden="true">#</a></h3><ul><li>term 完整匹配整个输入，正常 term 的查询性能会优于 match</li><li>match 对输入进行分词，然后匹配每个分词（需要注意的是，当在 keyword 类型下使用 match 时，他的表现和 term 一样）</li></ul><h3 id="bool-布尔查询" tabindex="-1">bool 布尔查询 <a class="header-anchor" href="#bool-布尔查询" aria-hidden="true">#</a></h3><p>bool查询是一个或者多个查询子句的组合，支持must 、must not、should、filter四种子句。</p><ul><li>must ：必须匹配，参与算分</li><li>should ：选择性匹配、参与算分</li><li>must not：必须不匹配，不参与算分</li><li>filter：必须匹配，不参与算分， 可以使用缓存</li></ul><p>bool子查询可以任意顺序出现、可以同时多个子查询</p><p>should must联用问题</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: {
        &quot;term&quot;: {&quot;gender&quot;: &quot;男&quot;}
      },
      &quot;should&quot;: [
        {
          &quot;term&quot;: {&quot;score&quot;: 70}
        },
        {
          &quot;term&quot;: {&quot;score&quot;: 80}
        }
      ]
    }
  }
}

解决方法

{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;should&quot;: [
        {
          &quot;bool&quot;: {
            &quot;must&quot;: [
              {
                &quot;term&quot;: {&quot;gender&quot;: &quot;男&quot;}
              },
              {
                &quot;term&quot;: {&quot;score&quot;: &quot;70&quot;}
              }
            ]
          }
        },
        {
          &quot;bool&quot;: {
            &quot;must&quot;: [
              {
                &quot;term&quot;: {&quot;gender&quot;: &quot;男&quot;}
              },
              {
                &quot;term&quot;: {&quot;score&quot;: &quot;80&quot;}
              }
            ]
          }
        }
      ]
    }
  }
}

{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {
          &quot;term&quot;: {&quot;gender&quot;: &quot;男&quot;}
        },
        {
          &quot;bool&quot;: {
            &quot;should&quot;: [
              {
                &quot;term&quot;: {&quot;score&quot;: 70}
              },
              {
                &quot;term&quot;: {&quot;score&quot;: 80}
              }
            ]
          }
        }
      ]
    }
  }
}

</code></pre></div><p>尽量在筛选的时候多使用不参与算分的must_not和filter，以保证性能良好</p><h3 id="query-string-字符串匹配" tabindex="-1">query_string 字符串匹配 <a class="header-anchor" href="#query-string-字符串匹配" aria-hidden="true">#</a></h3><p>字符串的专用匹配，可以多个条件、多个字段进行匹配</p><ul><li>逻辑运算符大写AND、OR、NOT</li><li>默认会对字符串分词，如果不需要分词 需要加上”“</li><li>默认运算符是OR</li><li>严格按照逻辑关系加括号</li></ul><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;query_string&quot;: {
      &quot;query&quot;: &quot;(truth AND good) OR Romeo&quot;,
      &quot;fields&quot;: [&quot;title&quot;,&quot;content&quot;]
    }
  }
}
</code></pre></div><h2 id="分页" tabindex="-1">分页 <a class="header-anchor" href="#分页" aria-hidden="true">#</a></h2><p>ES 提供了 3 种分页方式：</p><ul><li>from + size：最普通、简单的分页方式，但是会产生深分页的问题</li><li>search after：解决了深分页的问题，但只能一页一页地往下翻，不支持跳转到指定页数</li><li>scroll API/PIT：会创建数据快照，无法检索新写入的数据，适合对结果集进行遍历的时候使用</li></ul><h3 id="from-size-分页操作与深分页问题" tabindex="-1">from + size 分页操作与深分页问题 <a class="header-anchor" href="#from-size-分页操作与深分页问题" aria-hidden="true">#</a></h3><p>在我们检索数据时，系统会对数据按照相关性算分进行排序，然后默认返回前 10 条数据。我们可以使用 from + size 来指定获取哪些数据。其使用示例如下：</p><div class="language-"><pre><code>{
  &quot;from&quot;: 0, # 指定开始位置
  &quot;size&quot;: 10, # 指定获取文档个数
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  }
}
</code></pre></div><p>如上示例，使用 &quot;from&quot; 指定获取数据的开始位置，使用 &quot;size&quot; 指定获取文档的个数。</p><p>但当我们将 from 设置大于 10000 或者 size 设置大于 10001 的时候，这个查询将会报错：</p><div class="language-"><pre><code># 返回结果中的部分错误信息
......
&quot;root_cause&quot; : [
  {
    &quot;type&quot; : &quot;illegal_argument_exception&quot;,
    &quot;reason&quot; : &quot;Result window is too large, from + size must be less than or equal to: [10000] but was [10001]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level setting.&quot;
  }
],
&quot;type&quot; : &quot;search_phase_execution_exception&quot;,
&quot;reason&quot; : &quot;all shards failed&quot;,
&quot;phase&quot; : &quot;query&quot;,
&quot;grouped&quot; : true,
......
</code></pre></div><p>数据集合太大了，系统拒绝了我们的请求。我们可以使用 &quot;index.max_result_window&quot; 配置项设置这个上限：</p><div class="language-"><pre><code>PUT my_index/_settings
{
  &quot;index&quot;: {
    &quot;max_result_window&quot;: 20000
  }
}
</code></pre></div><p>这个配置有时候可以解决燃眉之急，但是这个上限设置过大的情况下会产生非常严重的后果。</p><p><img src="/assets/deeppage.663b5daa.png" alt=""></p><p>如上图，ES把数据保存到3个主分片中，当使用from = 90和size = 10进行分页的时候，ES会先从每个分片中分别获取100个文档，然后把这300个文档再汇聚到协调节点中进行排序，最后选出排序后的前100个文档，返回第90到99的文档。</p><p>可以看到，当页数变大（发生了深分页）的时候，在每个分片中获取的数据就越多，消耗的资源就越多。并且如果分片越多，汇聚到协调节点的数据也越多，最终汇聚到协调节点的文档数为：shard_amount * (from + size)。</p><h3 id="search-after" tabindex="-1">search after <a class="header-anchor" href="#search-after" aria-hidden="true">#</a></h3><p>使用 search after API 可以避免产生深分页的问题，不过 search after 不支持跳转到指定页数，只能一页页地往下翻。</p><p>使用 search after 接口分为两步：</p><ul><li>在 sort 中指定需要排序的字段，并且保证其值的唯一性（可以使用文档的 ID）</li><li>在下一次查询时，带上返回结果中最后一个文档的 sort 值进行访问</li></ul><div class="language-"><pre><code># 第一次调用 search after
POST my_index/_search
{
  &quot;size&quot;: 2,
  &quot;query&quot;: { &quot;match_all&quot;: {} },
  &quot;sort&quot;: [
    { &quot;_id&quot;: &quot;asc&quot; }
  ]
}

# 返回结果
&quot;hits&quot; : [
  {
    &quot;_id&quot; : &quot;1&quot;,
    &quot;_source&quot; : {
      &quot;book_id&quot; : &quot;4ee82467&quot;,
      &quot;price&quot; : 20.9
    },
    &quot;sort&quot; : [&quot;1&quot;]
  },
  {
    &quot;_id&quot; : &quot;2&quot;,
    &quot;_source&quot; : {
      &quot;book_id&quot; : &quot;4ee82462&quot;,
      &quot;price&quot; : 19.9
    },
    &quot;sort&quot; : [&quot;2&quot;]
  }
]

# 第二次调用 search after
POST books/_search
{
  &quot;size&quot;: 2,
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  },
  &quot;search_after&quot;:[&quot;2&quot;], # 设置为上次返回结果中最后一个文档的 sort 值
  &quot;sort&quot;: [
    { &quot;_id&quot;: &quot;asc&quot; }
  ]
}
</code></pre></div><p>因为有了唯一的排序值做保证，所以每个分片只需要返回比 sort 中唯一值大的 size 个数据即可。例如，上一次的查询返回的最后一个文档的 sort 为 a，那么这一次查询只需要在分片 1、2、3 中返回 size 个排序比 a 大的文档，协调节点汇总这些数据进行排序后返回 size 个结果给客户端。</p><h3 id="scroll-api" tabindex="-1">scroll API <a class="header-anchor" href="#scroll-api" aria-hidden="true">#</a></h3><p>当我们想对结果集进行遍历的时候，例如做全量数据导出时，可以使用 scroll API。scroll API 会创建数据快照，后续的访问将会基于这个快照来进行，所以无法检索新写入的数据。</p><div class="language-"><pre><code># 第一次使用 scroll API
POST my_index/_search?scroll=10m
{
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  },
  &quot;sort&quot;: { &quot;price&quot;: &quot;desc&quot; }, 
  &quot;size&quot;: 2
}

# 结果
{
  &quot;_scroll_id&quot; : &quot;FGluY2x1ZGVfY29udGV4dF9......==&quot;,
  &quot;hits&quot; : {
    &quot;hits&quot; : [
      {
        &quot;_id&quot; : &quot;6&quot;,
        &quot;_source&quot; : {
          &quot;book_id&quot; : &quot;4ee82467&quot;,
          &quot;price&quot; : 20.9
        }
      },
      ......
    ]
  }
}
</code></pre></div><p>如上示例，在第一次使用 scroll API 时需要初始化 scroll 搜索并且创建快照，使用 scroll 查询参数指定本次“查询上下文”（快照）的有效时间，本示例中为 10 分钟</p><div class="language-"><pre><code># 进行翻页
POST /_search/scroll                                                    
{
  &quot;scroll&quot; : &quot;5m&quot;,   
  &quot;scroll_id&quot; : &quot;FGluY2x1ZGVfY29udGV4dF9......==&quot; 
}
</code></pre></div><p>我们把上一次返回结果中的 _scroll_id 值放到本次请求的 scroll_id 字段中，并且指定“查询上下文”的有效时间为 5 分钟。同样此次的返回结果也会带有新的 _scroll_id。</p><h4 id="scroll-问题" tabindex="-1">scroll 问题 <a class="header-anchor" href="#scroll-问题" aria-hidden="true">#</a></h4><p><a href="https://discuss.elastic.co/t/ridiculously-long-scroll-id/12913" target="_blank" rel="noopener noreferrer">https://discuss.elastic.co/t/ridiculously-long-scroll-id/12913</a></p><h3 id="pit" tabindex="-1">PIT <a class="header-anchor" href="#pit" aria-hidden="true">#</a></h3><p>ES 7.10 中引入了 Point In Time 后，scroll API 就不建议被使用了。Point In Time（PIT）是 ES 7.10 中引入的新特性，PIT 是一个轻量级的数据状态视图，用户可以利用这个视图反复查询某个索引，仿佛这个索引的数据集停留在某个时间点上。也就是说，在创建 PIT 之后更新的数据是无法被检索到的。</p><p>当我们想要获取、统计以当前时间节点为准的数据而不考虑后续数据更新的时候，PIT 就显得非常有用了。使用 PIT 前需要显式使用 _pit API 获取一个 PID ID：</p><div class="language-"><pre><code># 使用 pit API 获取一个 PID ID
POST /my_index/_pit?keep_alive=20m

# 结果
{
  &quot;id&quot;: &quot;46ToAwMDaWR5BXV1aWQy......==&quot;
}
</code></pre></div><p>如上示例，使用 _pit 接口获取了一个 PIT ID，keep_alive 参数设置了这个视图的有效时长。有了这个 PIT ID 后续的查询就可以结合它来进行了</p><p>PIT 可以结合 search after 进行查询，能有效保证数据的一致性。 PIT 结合 search after 的流程与前面介绍的 search after 差不多，主要区别是需要在请求 body 中带上 PIT ID，其示例如下</p><div class="language-"><pre><code># 第一次调用 search after，因为使用了 PIT，这个时候搜索不需要指定 index 了。
POST _search
{
  &quot;size&quot;: 2,
  &quot;query&quot;: { &quot;match_all&quot;: {} },
  &quot;pit&quot;: {
    &quot;id&quot;:  &quot;46ToAwMDaWR5BXV1aWQy......==&quot;, # 添加 PIT id
    &quot;keep_alive&quot;: &quot;5m&quot; # 视图的有效时长
  },
  &quot;sort&quot;: [
    { &quot;price&quot;: &quot;desc&quot; } # 按价格倒序排序
  ]
}

# 结果
{
  &quot;pit_id&quot; : &quot;46ToAwMDaWR5BXV1aWQy......==&quot;,
  &quot;hits&quot; : {
    &quot;hits&quot; : [
      {
        &quot;_id&quot; : &quot;6&quot;,
        &quot;_source&quot; : {
          &quot;book_id&quot; : &quot;4ee82467&quot;,
          &quot;price&quot; : 20.9
        },
        &quot;sort&quot; : [20.9, 8589934593]
      },
      {
        &quot;_id&quot; : &quot;1&quot;,
        &quot;_source&quot; : {
          &quot;book_id&quot; : &quot;4ee82462&quot;
          &quot;price&quot; : 19.9
        },
        &quot;sort&quot; : [19.9, 8589934592]
      }
    ]
  }
}
</code></pre></div><p>在 pit 字段中指定 PIT ID 和设置 keep_alive 来指定视图的有效时长。需要注意的是，使用了 PIT 后也不需要在路径中指定索引名称了</p><p>在其返回结果中，sort 数组中包含了两个元素，其中第一个是我们用作排序的 price 的值，第二个值是一个隐含的排序值。所有的 PIT 请求都会自动加入一个隐式的用于排序的字段称为：_shard_doc，当然这个排序值可以显式指定。这个隐含的字段官方也称它为：tiebreaker（决胜字段），其代表的是文档的唯一值，保证了分页不会丢失或者分页结果的数据不会重复，其作用就好像原 search after 的 sort 字段中要指定的唯一值一样。</p><p>在进行翻页的时候和原 search after 一样，需要把上次结果中最后一个文档的 sort 值带上：</p><div class="language-"><pre><code># 第二次调用 search after，因为使用了 PIT，这个时候搜索不需要指定 index 了。
POST _search
{
  &quot;size&quot;: 2,
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  },
  &quot;pit&quot;: {
    &quot;id&quot;:  &quot;46ToAwMDaWR5BXV1aWQy......==&quot;, # 添加 PIT id
    &quot;keep_alive&quot;: &quot;5m&quot; # 视图的有效时长
  },
  &quot;search_after&quot;: [19.9, 8589934592], # 上次结果中最后一个文档的 sort 值
  &quot;sort&quot;: [
    { &quot;price&quot;: &quot;desc&quot; }
  ]
}
</code></pre></div><h1 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-hidden="true">#</a></h1><h2 id="精确匹配" tabindex="-1">精确匹配 <a class="header-anchor" href="#精确匹配" aria-hidden="true">#</a></h2><h3 id="忽略大小写" tabindex="-1">忽略大小写 <a class="header-anchor" href="#忽略大小写" aria-hidden="true">#</a></h3><p>text的创建文档时是会分词并且转成小写的，但是精确匹配keyword是不分词的，也不会转成小写。有时候我们想要忽略大小写的精确匹配</p><p>需要在创建索引的时候，设置忽略大小写</p><div class="language-"><pre><code>{
  &quot;settings&quot;: {
    &quot;number_of_replicas&quot;: 1,
    &quot;number_of_shards&quot;: 0,
    # 1、指定忽略大小写
    &quot;analysis&quot;: {
      &quot;normalizer&quot;: {
        &quot;lowercase_normalizer&quot;: {
          &quot;type&quot;: &quot;custom&quot;,
          &quot;char_filter&quot;: [],
          &quot;filter&quot;: [
            &quot;lowercase&quot;
          ]
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;tag&quot;: {
        &quot;type&quot;: &quot;keyword&quot;,
        # 2、设置忽略大小写
        &quot;normalizer&quot;: &quot;lowercase_normalizer&quot;
      }
  }
}
</code></pre></div><p>使用case_insensitive，仅支持term</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;title&quot;: {
        &quot;value&quot;: &quot;Romeo&quot;,
        &quot;case_insensitive&quot;: true
      }
    }
  }
}
</code></pre></div><h2 id="分词技巧" tabindex="-1">分词技巧 <a class="header-anchor" href="#分词技巧" aria-hidden="true">#</a></h2><p>索引时用ik_max_word(最细粒度划分)，在搜索时用ik_smart（最少切分） 即：索引时最大化的将文章内容分词，搜索时更精确的搜索到想要的结果。</p><div class="language-"><pre><code>{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;content&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;,
        &quot;fields&quot;: {
          &quot;keyword&quot;: {
            &quot;type&quot;: &quot;keyword&quot;,
            &quot;ignore_above&quot;: 256
          }
        }
      }
    }
  }
}

{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;title&quot;: {
        &quot;analyzer&quot;: &quot;ik_smart&quot;,
        &quot;query&quot;: &quot;文章&quot;
      }
    }
  }
}
</code></pre></div><h2 id="返回数据具体总条数" tabindex="-1">返回数据具体总条数 <a class="header-anchor" href="#返回数据具体总条数" aria-hidden="true">#</a></h2><p>track_total_hits参数默认为false，为false时，当搜索到的数据&gt;10000条，则只显示10000条，为true时，可以显示详细条数</p><h2 id="返回指定字段" tabindex="-1">返回指定字段 <a class="header-anchor" href="#返回指定字段" aria-hidden="true">#</a></h2><p>不是所有字段都需要返回，可以指定需要返回的字段</p><p>可以使用通配符*</p><div class="language-"><pre><code>{
  &quot;from&quot;: 0,
  &quot;size&quot;: 1,
  &quot;query&quot;: {},
  &quot;_source&quot;: {
    # 指定返回字段
    &quot;includes&quot;: [
      &quot;title&quot;
    ],
    # 指定不返回字段
    &quot;excludes&quot;: [&quot;name&quot;,&quot;bir*&quot;]
  }
}
</code></pre></div><h2 id="copy-to" tabindex="-1">copy_to <a class="header-anchor" href="#copy-to" aria-hidden="true">#</a></h2><p>Elasticsearch允许在映射中为某个字段定义copy_to参数，以实现复制多个其他字段的内容，这样在搜索一个字段时能够达到同时搜索多个字段的效果，使用字段复制比使用多字段匹配Multi_match性能更好。</p><div class="language-"><pre><code>{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;title&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;copy_to&quot;: &quot;titleBrief&quot; # 指定copy_to
      },
      &quot;brief&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;copy_to&quot;: &quot;titleBrief&quot; # 指定copy_to
      }
    }
  }
}


{
    {
    &quot;query&quot;: {
        &quot;match&quot;: {
        &quot;titleBrief&quot;: &quot;红&quot;
        }
    }
    }
}
</code></pre></div><h2 id="执行性能" tabindex="-1">执行性能 <a class="header-anchor" href="#执行性能" aria-hidden="true">#</a></h2><p>Profile API 用于查看 DSL 性能瓶颈。只需要添加 &quot;profile&quot;: true 即可查看 DSL 的执行性能</p><div class="language-"><pre><code>{
  &quot;profile&quot;: true,
  &quot;query&quot;: {
    &quot;query_string&quot;: {
      &quot;query&quot;: &quot;tag:(taga) AND tag_type:(A OR b) AND user:(173)&quot;
    }
  }
}
</code></pre></div><h1 id="suggester-api搜索提示" tabindex="-1">Suggester API搜索提示 <a class="header-anchor" href="#suggester-api搜索提示" aria-hidden="true">#</a></h1><p>ES提供了suggseter api，提供了4种类型的suggseters：Term Suggester（基于单词的纠错补全）、Phrase Suggester（基于短语的纠错补全）、Complete Suggester（自动补全单词，输入词语的前半部分，自动补全单词）、Context Suggseter（基于上下文的补全提示，可以实现上下文感知推荐）</p><h2 id="term-suggester" tabindex="-1">Term Suggester <a class="header-anchor" href="#term-suggester" aria-hidden="true">#</a></h2><p>将输入的文本分解为Token，然后在索引的字段里查找相似的term返回</p><div class="language-"><pre><code>{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;database&quot;: &quot;posgresql&quot;
    }
  },
  &quot;suggest&quot;: {
    &quot;my-term-suggestion&quot;: {
      &quot;text&quot;: &quot;posgresql&quot;,
      &quot;term&quot;: {
        &quot;suggest_mode&quot;: &quot;missing&quot;,
        &quot;field&quot;: &quot;database&quot;
      }
    },
    &quot;my-term-suggestion2&quot;: {
      &quot;text&quot;: &quot;oracla&quot;,
      &quot;term&quot;: {
        &quot;suggest_mode&quot;: &quot;missing&quot;,
        &quot;field&quot;: &quot;database&quot;
      }
    }
  }
}
</code></pre></div></div></div><footer class="page-footer" data-v-8fcebc32 data-v-b65b4b36><div class="edit" data-v-b65b4b36><div class="edit-link" data-v-b65b4b36 data-v-55695e90><!----></div></div><div class="updated" data-v-b65b4b36><!----></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--><div class="site-footer"> Copyright © 2021-present <a class="vitepress">hassan</a><br> Powered by <a class="vitepress" target="_blank" href="//vitepress.vuejs.org/">VitePress</a></div><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"5aa7f108\",\"page_2.md\":\"ff99fc67\",\"page_3.md\":\"9417d29e\",\"page_4.md\":\"865a8be1\",\"page_5.md\":\"dc2a6c1b\",\"page_6.md\":\"2ed688cb\",\"pages_about.md\":\"53f7aad0\",\"pages_archives.md\":\"c10a9f9f\",\"pages_tags.md\":\"013dfafc\",\"posts_blog_github-action.md\":\"251d62a8\",\"posts_blog_vitepress-github.md\":\"12b9dc4b\",\"posts_contract_abi.md\":\"ab8bb451\",\"posts_contract_abstract_interface.md\":\"d2bc04c6\",\"posts_contract_call.md\":\"4d77cf84\",\"posts_contract_call_contract.md\":\"37a34c4a\",\"posts_contract_constructor_modifer.md\":\"d7312b47\",\"posts_contract_create.md\":\"b5dac614\",\"posts_contract_data_reference.md\":\"f5be8780\",\"posts_contract_data_storage.md\":\"9d7a44b5\",\"posts_contract_delegatecall.md\":\"81d6058c\",\"posts_contract_event.md\":\"cc3719f2\",\"posts_contract_exception.md\":\"e1da10b7\",\"posts_contract_fun_overloading.md\":\"26e3edaa\",\"posts_contract_fun_return_val.md\":\"b414a0ec\",\"posts_contract_fun_type.md\":\"a86df5c1\",\"posts_contract_import.md\":\"6d61d620\",\"posts_contract_inheritance.md\":\"c92487f6\",\"posts_contract_library.md\":\"a12857ca\",\"posts_contract_mapping.md\":\"6de4e2b8\",\"posts_contract_receive_eth.md\":\"baf82c62\",\"posts_contract_selector.md\":\"e6081b3e\",\"posts_contract_send_eth.md\":\"08b01710\",\"posts_contract_value_type.md\":\"52e3d384\",\"posts_docker_accelerator.md\":\"81593276\",\"posts_es_elasticsearch.md\":\"f7704f13\",\"posts_es_es_base_concept.md\":\"84a7077c\",\"posts_es_es_dsl_one.md\":\"c17ce883\",\"posts_es_es_dsl_query.md\":\"fb030b55\",\"posts_es_es_dsl_three.md\":\"6dc69e75\",\"posts_es_es_dsl_two.md\":\"7f598f55\",\"posts_es_es_index.md\":\"8ad5ba1b\",\"posts_es_es_query_agg.md\":\"23e65cfb\",\"posts_es_es_type.md\":\"7cdb86bf\",\"posts_front_cors.md\":\"2eaee861\",\"posts_git_git-learn.md\":\"75d95f86\",\"posts_java_base_java_lang.md\":\"be05db40\",\"posts_linux_linux_fork.md\":\"bd8e757e\",\"posts_linux_linux_pipe.md\":\"45acea12\",\"posts_linux_linux_recv.md\":\"de56fa97\",\"posts_mysql_groupby_orderby.md\":\"7610d54d\",\"posts_mysql_mysql_lock_one.md\":\"5de2a3e5\",\"posts_mysql_mysql_mvcc.md\":\"411c9cb2\",\"posts_mysql_mysql_partition.md\":\"8f80f24a\",\"posts_mysql_mysql_transaction.md\":\"a4dc14ab\",\"posts_network_tcp-model.md\":\"e6948fef\",\"posts_network_tcp-three-shark.md\":\"f96499e6\",\"posts_network_tcp-time_wait.md\":\"434f1cbe\",\"posts_network_tpcip-one.md\":\"e81803cd\",\"posts_personal_information.md\":\"7e022fec\",\"posts_personal_study.md\":\"3296dc05\",\"posts_personal_think-habit.md\":\"91b0a9c8\",\"posts_personal_think-object.md\":\"906700b7\",\"posts_personal_work-five.md\":\"a740a96a\",\"posts_postgresql_pg_create.md\":\"874ca2f5\",\"posts_postgresql_pg_debug.md\":\"5f1b6ce6\",\"posts_postgresql_pg_pages.md\":\"e4d8b761\",\"posts_tools_parallel-centos.md\":\"ecf8314f\"}")</script>
    <script type="module" async src="/assets/app.4fa09c86.js"></script>
    
  </body>
</html>